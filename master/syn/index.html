<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `syn` crate."><meta name="keywords" content="rust, rustlang, rust-lang, syn"><title>syn - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><p class='location'>Crate syn</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'syn', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><input class="search-input" name="search" autocomplete="off" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='in-band'>Crate <a class="mod" href=''>syn</a></span><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/syn/lib.rs.html#9-751' title='goto source code'>[src]</a></span></h1><div class='docblock'><p>Syn is a parsing library for parsing a stream of Rust tokens into a syntax
tree of Rust source code.</p>
<p>Currently this library is geared toward the <a href="https://github.com/rust-lang/rfcs/blob/master/text/1681-macros-1.1.md">custom derive</a> use case but
contains some APIs that may be useful for Rust procedural macros more
generally.</p>
<ul>
<li>
<p><strong>Data structures</strong> — Syn provides a complete syntax tree that can
represent any valid Rust source code. The syntax tree is rooted at
<a href="struct.File.html"><code>syn::File</code></a> which represents a full source file, but there are other
entry points that may be useful to procedural macros including
<a href="enum.Item.html"><code>syn::Item</code></a>, <a href="enum.Expr.html"><code>syn::Expr</code></a> and <a href="enum.Type.html"><code>syn::Type</code></a>.</p>
</li>
<li>
<p><strong>Custom derives</strong> — Of particular interest to custom derives is
<a href="struct.DeriveInput.html"><code>syn::DeriveInput</code></a> which is any of the three legal input items to a
derive macro. An example below shows using this type in a library that can
derive implementations of a trait of your own.</p>
</li>
<li>
<p><strong>Parser combinators</strong> — Parsing in Syn is built on a suite of public
parser combinator macros that you can use for parsing any token-based
syntax you dream up within a <code>functionlike!(...)</code> procedural macro. Every
syntax tree node defined by Syn is individually parsable and may be used
as a building block for custom syntaxes, or you may do it all yourself
working from the most primitive tokens.</p>
</li>
<li>
<p><strong>Location information</strong> — Every token parsed by Syn is associated with a
<code>Span</code> that tracks line and column information back to the source of that
token. These spans allow a procedural macro to display detailed error
messages pointing to all the right places in the user's code. There is an
example of this below.</p>
</li>
<li>
<p><strong>Feature flags</strong> — Functionality is aggressively feature gated so your
procedural macros enable only what they need, and do not pay in compile
time for all the rest.</p>
</li>
</ul>
<p><em>Version requirement: Syn supports any compiler version back to Rust's very
first support for procedural macros in Rust 1.15.0. Some features especially
around error reporting are only available in newer compilers or on the
nightly channel.</em></p>
<h2 id="example-of-a-custom-derive" class="section-header"><a href="#example-of-a-custom-derive">Example of a custom derive</a></h2>
<p>The canonical custom derive using Syn looks like this. We write an ordinary
Rust function tagged with a <code>proc_macro_derive</code> attribute and the name of
the trait we are deriving. Any time that derive appears in the user's code,
the Rust compiler passes their data structure as tokens into our macro. We
get to execute arbitrary Rust code to figure out what to do with those
tokens, then hand some tokens back to the compiler to compile into the
user's crate.</p>
<pre><code class="language-toml">[dependencies]
syn = &quot;0.14&quot;
quote = &quot;0.6&quot;

[lib]
proc-macro = true
</code></pre>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">proc_macro</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">syn</span>;

<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">quote</span>;

<span class="kw">use</span> <span class="ident">proc_macro</span>::<span class="ident">TokenStream</span>;
<span class="kw">use</span> <span class="ident">syn</span>::<span class="ident">DeriveInput</span>;

<span class="attribute">#[<span class="ident">proc_macro_derive</span>(<span class="ident">MyMacro</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">my_macro</span>(<span class="ident">input</span>: <span class="ident">TokenStream</span>) <span class="op">-&gt;</span> <span class="ident">TokenStream</span> {
    <span class="comment">// Parse the input tokens into a syntax tree</span>
    <span class="kw">let</span> <span class="ident">input</span>: <span class="ident">DeriveInput</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="ident">parse</span>(<span class="ident">input</span>).<span class="ident">unwrap</span>();

    <span class="comment">// Build the output, possibly using quasi-quotation</span>
    <span class="kw">let</span> <span class="ident">expanded</span> <span class="op">=</span> <span class="macro">quote</span><span class="macro">!</span> {
        <span class="comment">// ...</span>
    };

    <span class="comment">// Hand the output tokens back to the compiler</span>
    <span class="ident">expanded</span>.<span class="ident">into</span>()
}</pre>
<p>The <a href="https://github.com/dtolnay/syn/tree/master/examples/heapsize"><code>heapsize</code></a> example directory shows a complete working Macros 1.1
implementation of a custom derive. It works on any Rust compiler &gt;=1.15.0.
The example derives a <code>HeapSize</code> trait which computes an estimate of the
amount of heap memory owned by a value.</p>

<pre class="rust rust-example-rendered">
<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">HeapSize</span> {
    <span class="doccomment">/// Total number of bytes of heap memory owned by `self`.</span>
    <span class="kw">fn</span> <span class="ident">heap_size_of_children</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">usize</span>;
}</pre>
<p>The custom derive allows users to write <code>#[derive(HeapSize)]</code> on data
structures in their program.</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">HeapSize</span>)]</span>
<span class="kw">struct</span> <span class="ident">Demo</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">T</span>: <span class="question-mark">?</span><span class="ident">Sized</span><span class="op">&gt;</span> {
    <span class="ident">a</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
    <span class="ident">b</span>: <span class="ident">u8</span>,
    <span class="ident">c</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">str</span>,
    <span class="ident">d</span>: <span class="ident">String</span>,
}</pre>
<h2 id="spans-and-error-reporting" class="section-header"><a href="#spans-and-error-reporting">Spans and error reporting</a></h2>
<p>The <a href="https://github.com/dtolnay/syn/tree/master/examples/heapsize2"><code>heapsize2</code></a> example directory is an extension of the <code>heapsize</code>
example that demonstrates some of the hygiene and error reporting properties
of Macros 2.0. This example currently requires a nightly Rust compiler
&gt;=1.24.0-nightly but we are working to stabilize all of the APIs involved.</p>
<p>The token-based procedural macro API provides great control over where the
compiler's error messages are displayed in user code. Consider the error the
user sees if one of their field types does not implement <code>HeapSize</code>.</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">HeapSize</span>)]</span>
<span class="kw">struct</span> <span class="ident">Broken</span> {
    <span class="ident">ok</span>: <span class="ident">String</span>,
    <span class="ident">bad</span>: <span class="ident">std</span>::<span class="ident">thread</span>::<span class="ident">Thread</span>,
}</pre>
<p>In the Macros 1.1 string-based procedural macro world, the resulting error
would point unhelpfully to the invocation of the derive macro and not to the
actual problematic field.</p>
<pre><code class="language-text">error[E0599]: no method named `heap_size_of_children` found for type `std::thread::Thread` in the current scope
 --&gt; src/main.rs:4:10
  |
4 | #[derive(HeapSize)]
  |          ^^^^^^^^
</code></pre>
<p>By tracking span information all the way through the expansion of a
procedural macro as shown in the <code>heapsize2</code> example, token-based macros in
Syn are able to trigger errors that directly pinpoint the source of the
problem.</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::thread::Thread: HeapSize` is not satisfied
 --&gt; src/main.rs:7:5
  |
7 |     bad: std::thread::Thread,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `HeapSize` is not implemented for `Thread`
</code></pre>
<h2 id="parsing-a-custom-syntax-using-combinators" class="section-header"><a href="#parsing-a-custom-syntax-using-combinators">Parsing a custom syntax using combinators</a></h2>
<p>The <a href="https://github.com/dtolnay/syn/tree/master/examples/lazy-static"><code>lazy-static</code></a> example directory shows the implementation of a
<code>functionlike!(...)</code> procedural macro in which the input tokens are parsed
using <a href="https://github.com/Geal/nom"><code>nom</code></a>-style parser combinators.</p>
<p>The example reimplements the popular <code>lazy_static</code> crate from crates.io as a
procedural macro.</p>

<pre class="rust rust-example-rendered">
<span class="macro">lazy_static</span><span class="macro">!</span> {
    <span class="kw">static</span> <span class="kw-2">ref</span> <span class="ident">USERNAME</span>: <span class="ident">Regex</span> <span class="op">=</span> <span class="ident">Regex</span>::<span class="ident">new</span>(<span class="string">&quot;^[a-z0-9_-]{3,16}$&quot;</span>).<span class="ident">unwrap</span>();
}</pre>
<p>The implementation shows how to trigger custom warnings and error messages
on the macro input.</p>
<pre><code class="language-text">warning: come on, pick a more creative name
  --&gt; src/main.rs:10:16
   |
10 |     static ref FOO: String = &quot;lazy_static&quot;.to_owned();
   |                ^^^
</code></pre>
<h2 id="debugging" class="section-header"><a href="#debugging">Debugging</a></h2>
<p>When developing a procedural macro it can be helpful to look at what the
generated code looks like. Use <code>cargo rustc -- -Zunstable-options --pretty=expanded</code> or the <a href="https://github.com/dtolnay/cargo-expand"><code>cargo expand</code></a> subcommand.</p>
<p>To show the expanded code for some crate that uses your procedural macro,
run <code>cargo expand</code> from that crate. To show the expanded code for one of
your own test cases, run <code>cargo expand --test the_test_case</code> where the last
argument is the name of the test file without the <code>.rs</code> extension.</p>
<p>This write-up by Brandon W Maister discusses debugging in more detail:
<a href="https://quodlibetor.github.io/posts/debugging-rusts-new-custom-derive-system/">Debugging Rust's new Custom Derive system</a>.</p>
<h2 id="optional-features" class="section-header"><a href="#optional-features">Optional features</a></h2>
<p>Syn puts a lot of functionality behind optional features in order to
optimize compile time for the most common use cases. The following features
are available.</p>
<ul>
<li><strong><code>derive</code></strong> <em>(enabled by default)</em> — Data structures for representing the
possible input to a custom derive, including structs and enums and types.</li>
<li><strong><code>full</code></strong> — Data structures for representing the syntax tree of all valid
Rust source code, including items and expressions.</li>
<li><strong><code>parsing</code></strong> <em>(enabled by default)</em> — Ability to parse input tokens into
a syntax tree node of a chosen type.</li>
<li><strong><code>printing</code></strong> <em>(enabled by default)</em> — Ability to print a syntax tree
node as tokens of Rust source code.</li>
<li><strong><code>visit</code></strong> — Trait for traversing a syntax tree.</li>
<li><strong><code>visit-mut</code></strong> — Trait for traversing and mutating in place a syntax
tree.</li>
<li><strong><code>fold</code></strong> — Trait for transforming an owned syntax tree.</li>
<li><strong><code>clone-impls</code></strong> <em>(enabled by default)</em> — Clone impls for all syntax tree
types.</li>
<li><strong><code>extra-traits</code></strong> — Debug, Eq, PartialEq, Hash impls for all syntax tree
types.</li>
<li><strong><code>proc-macro</code></strong> <em>(enabled by default)</em> — Runtime dependency on the
dynamic library libproc_macro from rustc toolchain.</li>
</ul>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="mod" href="buffer/index.html"
                                  title='mod syn::buffer'>buffer</a></td>
                           <td class='docblock-short'>
                                <p>A stably addressed token buffer supporting efficient traversal based on a
cheaply copyable cursor.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="punctuated/index.html"
                                  title='mod syn::punctuated'>punctuated</a></td>
                           <td class='docblock-short'>
                                <p>A punctuated sequence of syntax tree nodes separated by punctuation.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="spanned/index.html"
                                  title='mod syn::spanned'>spanned</a></td>
                           <td class='docblock-short'>
                                <p>A trait that can provide the <code>Span</code> of the complete contents of a syntax
tree node.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="synom/index.html"
                                  title='mod syn::synom'>synom</a></td>
                           <td class='docblock-short'>
                                <p>Parsing interface for parsing a token stream into a syntax tree node.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="token/index.html"
                                  title='mod syn::token'>token</a></td>
                           <td class='docblock-short'>
                                <p>Tokens representing Rust punctuation, keywords, and delimiters.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="visit/index.html"
                                  title='mod syn::visit'>visit</a></td>
                           <td class='docblock-short'>
                                <p>Syntax tree traversal to walk a shared borrow of a syntax tree.</p>

                           </td>
                       </tr></table><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.Token.html"
                                  title='macro syn::Token'>Token</a></td>
                           <td class='docblock-short'>
                                <p>A type-macro that expands to the name of the Rust type representation of a
given token.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.alt.html"
                                  title='macro syn::alt'>alt</a></td>
                           <td class='docblock-short'>
                                <p>Run a series of parsers, returning the result of the first one which
succeeds.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.braces.html"
                                  title='macro syn::braces'>braces</a></td>
                           <td class='docblock-short'>
                                <p>Parse inside of <code>{</code> <code>}</code> curly braces.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.brackets.html"
                                  title='macro syn::brackets'>brackets</a></td>
                           <td class='docblock-short'>
                                <p>Parse inside of <code>[</code> <code>]</code> square brackets.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.call.html"
                                  title='macro syn::call'>call</a></td>
                           <td class='docblock-short'>
                                <p>Invoke the given parser function with zero or more arguments.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.cond.html"
                                  title='macro syn::cond'>cond</a></td>
                           <td class='docblock-short'>
                                <p>Execute a parser only if a condition is met, otherwise return None.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.cond_reduce.html"
                                  title='macro syn::cond_reduce'>cond_reduce</a></td>
                           <td class='docblock-short'>
                                <p>Execute a parser only if a condition is met, otherwise fail to parse.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.custom_keyword.html"
                                  title='macro syn::custom_keyword'>custom_keyword</a></td>
                           <td class='docblock-short'>
                                <p>Parse the given word as a keyword.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.do_parse.html"
                                  title='macro syn::do_parse'>do_parse</a></td>
                           <td class='docblock-short'>
                                <p>Run a series of parsers, optionally naming each intermediate result,
followed by a step to combine the intermediate results.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.epsilon.html"
                                  title='macro syn::epsilon'>epsilon</a></td>
                           <td class='docblock-short'>
                                <p>Parses nothing and always succeeds.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.input_end.html"
                                  title='macro syn::input_end'>input_end</a></td>
                           <td class='docblock-short'>
                                <p>Parse nothing and succeed only if the end of the enclosing block has been
reached.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.keyword.html"
                                  title='macro syn::keyword'>keyword</a></td>
                           <td class='docblock-short'>
                                <p>Parse a single Rust keyword token.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.many0.html"
                                  title='macro syn::many0'>many0</a></td>
                           <td class='docblock-short'>
                                <p>Parse zero or more values using the given parser.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.map.html"
                                  title='macro syn::map'>map</a></td>
                           <td class='docblock-short'>
                                <p>Transform the result of a parser by applying a function or closure.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.named.html"
                                  title='macro syn::named'>named</a></td>
                           <td class='docblock-short'>
                                <p>Define a parser function with the signature expected by syn parser
combinators.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.not.html"
                                  title='macro syn::not'>not</a></td>
                           <td class='docblock-short'>
                                <p>Invert the result of a parser by parsing successfully if the given parser
fails to parse and vice versa.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.option.html"
                                  title='macro syn::option'>option</a></td>
                           <td class='docblock-short'>
                                <p>Turn a failed parse into <code>None</code> and a successful parse into <code>Some</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.parens.html"
                                  title='macro syn::parens'>parens</a></td>
                           <td class='docblock-short'>
                                <p>Parse inside of <code>(</code> <code>)</code> parentheses.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.parse_quote.html"
                                  title='macro syn::parse_quote'>parse_quote</a></td>
                           <td class='docblock-short'>
                                <p>Quasi-quotation macro that accepts input like the <a href="https://docs.rs/quote/0.4/quote/index.html"><code>quote!</code></a> macro but uses
type inference to figure out a return type for those tokens.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.punct.html"
                                  title='macro syn::punct'>punct</a></td>
                           <td class='docblock-short'>
                                <p>Parse a single Rust punctuation token.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.reject.html"
                                  title='macro syn::reject'>reject</a></td>
                           <td class='docblock-short'>
                                <p>Unconditionally fail to parse anything.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.switch.html"
                                  title='macro syn::switch'>switch</a></td>
                           <td class='docblock-short'>
                                <p>Pattern-match the result of a parser to select which other parser to run.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.syn.html"
                                  title='macro syn::syn'>syn</a></td>
                           <td class='docblock-short'>
                                <p>Parse any type that implements the <code>Synom</code> trait.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tuple.html"
                                  title='macro syn::tuple'>tuple</a></td>
                           <td class='docblock-short'>
                                <p>Run a series of parsers and produce all of the results in a tuple.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.value.html"
                                  title='macro syn::value'>value</a></td>
                           <td class='docblock-short'>
                                <p>Produce the given value without parsing anything.</p>

                           </td>
                       </tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Abi.html"
                                  title='struct syn::Abi'>Abi</a></td>
                           <td class='docblock-short'>
                                <p>The binary interface of a function: <code>extern &quot;C&quot;</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.AngleBracketedGenericArguments.html"
                                  title='struct syn::AngleBracketedGenericArguments'>AngleBracketedGenericArguments</a></td>
                           <td class='docblock-short'>
                                <p>Angle bracketed arguments of a path segment: the <code>&lt;K, V&gt;</code> in <code>HashMap&lt;K, V&gt;</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Attribute.html"
                                  title='struct syn::Attribute'>Attribute</a></td>
                           <td class='docblock-short'>
                                <p>An attribute like <code>#[repr(transparent)]</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.BareFnArg.html"
                                  title='struct syn::BareFnArg'>BareFnArg</a></td>
                           <td class='docblock-short'>
                                <p>An argument in a function type: the <code>usize</code> in <code>fn(usize) -&gt; bool</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Binding.html"
                                  title='struct syn::Binding'>Binding</a></td>
                           <td class='docblock-short'>
                                <p>A binding (equality constraint) on an associated type: <code>Item = u8</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.BoundLifetimes.html"
                                  title='struct syn::BoundLifetimes'>BoundLifetimes</a></td>
                           <td class='docblock-short'>
                                <p>A set of bound lifetimes: <code>for&lt;'a, 'b, 'c&gt;</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ConstParam.html"
                                  title='struct syn::ConstParam'>ConstParam</a></td>
                           <td class='docblock-short'>
                                <p>A const generic parameter: <code>const LENGTH: usize</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.DataEnum.html"
                                  title='struct syn::DataEnum'>DataEnum</a></td>
                           <td class='docblock-short'>
                                <p>An enum input to a <code>proc_macro_derive</code> macro.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.DataStruct.html"
                                  title='struct syn::DataStruct'>DataStruct</a></td>
                           <td class='docblock-short'>
                                <p>A struct input to a <code>proc_macro_derive</code> macro.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.DataUnion.html"
                                  title='struct syn::DataUnion'>DataUnion</a></td>
                           <td class='docblock-short'>
                                <p>A tagged union input to a <code>proc_macro_derive</code> macro.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.DeriveInput.html"
                                  title='struct syn::DeriveInput'>DeriveInput</a></td>
                           <td class='docblock-short'>
                                <p>Data structure sent to a <code>proc_macro_derive</code> macro.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprArray.html"
                                  title='struct syn::ExprArray'>ExprArray</a></td>
                           <td class='docblock-short'>
                                <p>A slice literal expression: <code>[a, b, c, d]</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprAssign.html"
                                  title='struct syn::ExprAssign'>ExprAssign</a></td>
                           <td class='docblock-short'>
                                <p>An assignment expression: <code>a = compute()</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprAssignOp.html"
                                  title='struct syn::ExprAssignOp'>ExprAssignOp</a></td>
                           <td class='docblock-short'>
                                <p>A compound assignment expression: <code>counter += 1</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprBinary.html"
                                  title='struct syn::ExprBinary'>ExprBinary</a></td>
                           <td class='docblock-short'>
                                <p>A binary operation: <code>a + b</code>, <code>a * b</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprBlock.html"
                                  title='struct syn::ExprBlock'>ExprBlock</a></td>
                           <td class='docblock-short'>
                                <p>A blocked scope: <code>{ ... }</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprBox.html"
                                  title='struct syn::ExprBox'>ExprBox</a></td>
                           <td class='docblock-short'>
                                <p>A box expression: <code>box f</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprBreak.html"
                                  title='struct syn::ExprBreak'>ExprBreak</a></td>
                           <td class='docblock-short'>
                                <p>A <code>break</code>, with an optional label to break and an optional
expression.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprCall.html"
                                  title='struct syn::ExprCall'>ExprCall</a></td>
                           <td class='docblock-short'>
                                <p>A function call expression: <code>invoke(a, b)</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprCast.html"
                                  title='struct syn::ExprCast'>ExprCast</a></td>
                           <td class='docblock-short'>
                                <p>A cast expression: <code>foo as f64</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprCatch.html"
                                  title='struct syn::ExprCatch'>ExprCatch</a></td>
                           <td class='docblock-short'>
                                <p>A catch expression: <code>do catch { ... }</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprClosure.html"
                                  title='struct syn::ExprClosure'>ExprClosure</a></td>
                           <td class='docblock-short'>
                                <p>A closure expression: <code>|a, b| a + b</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprContinue.html"
                                  title='struct syn::ExprContinue'>ExprContinue</a></td>
                           <td class='docblock-short'>
                                <p>A <code>continue</code>, with an optional label.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprField.html"
                                  title='struct syn::ExprField'>ExprField</a></td>
                           <td class='docblock-short'>
                                <p>Access of a named struct field (<code>obj.k</code>) or unnamed tuple struct
field (<code>obj.0</code>).</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprForLoop.html"
                                  title='struct syn::ExprForLoop'>ExprForLoop</a></td>
                           <td class='docblock-short'>
                                <p>A for loop: <code>for pat in expr { ... }</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprGroup.html"
                                  title='struct syn::ExprGroup'>ExprGroup</a></td>
                           <td class='docblock-short'>
                                <p>An expression contained within invisible delimiters.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprIf.html"
                                  title='struct syn::ExprIf'>ExprIf</a></td>
                           <td class='docblock-short'>
                                <p>An <code>if</code> expression with an optional <code>else</code> block: <code>if expr { ... } else { ... }</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprIfLet.html"
                                  title='struct syn::ExprIfLet'>ExprIfLet</a></td>
                           <td class='docblock-short'>
                                <p>An <code>if let</code> expression with an optional <code>else</code> block: <code>if let pat = expr { ... } else { ... }</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprInPlace.html"
                                  title='struct syn::ExprInPlace'>ExprInPlace</a></td>
                           <td class='docblock-short'>
                                <p>A placement expression: <code>place &lt;- value</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprIndex.html"
                                  title='struct syn::ExprIndex'>ExprIndex</a></td>
                           <td class='docblock-short'>
                                <p>A square bracketed indexing expression: <code>vector[2]</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprLit.html"
                                  title='struct syn::ExprLit'>ExprLit</a></td>
                           <td class='docblock-short'>
                                <p>A literal in place of an expression: <code>1</code>, <code>&quot;foo&quot;</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprLoop.html"
                                  title='struct syn::ExprLoop'>ExprLoop</a></td>
                           <td class='docblock-short'>
                                <p>Conditionless loop: <code>loop { ... }</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprMacro.html"
                                  title='struct syn::ExprMacro'>ExprMacro</a></td>
                           <td class='docblock-short'>
                                <p>A macro invocation expression: <code>format!(&quot;{}&quot;, q)</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprMatch.html"
                                  title='struct syn::ExprMatch'>ExprMatch</a></td>
                           <td class='docblock-short'>
                                <p>A <code>match</code> expression: <code>match n { Some(n) =&gt; {}, None =&gt; {} }</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprMethodCall.html"
                                  title='struct syn::ExprMethodCall'>ExprMethodCall</a></td>
                           <td class='docblock-short'>
                                <p>A method call expression: <code>x.foo::&lt;T&gt;(a, b)</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprParen.html"
                                  title='struct syn::ExprParen'>ExprParen</a></td>
                           <td class='docblock-short'>
                                <p>A parenthesized expression: <code>(a + b)</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprPath.html"
                                  title='struct syn::ExprPath'>ExprPath</a></td>
                           <td class='docblock-short'>
                                <p>A path like <code>std::mem::replace</code> possibly containing generic
parameters and a qualified self-type.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprRange.html"
                                  title='struct syn::ExprRange'>ExprRange</a></td>
                           <td class='docblock-short'>
                                <p>A range expression: <code>1..2</code>, <code>1..</code>, <code>..2</code>, <code>1..=2</code>, <code>..=2</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprReference.html"
                                  title='struct syn::ExprReference'>ExprReference</a></td>
                           <td class='docblock-short'>
                                <p>A referencing operation: <code>&amp;a</code> or <code>&amp;mut a</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprRepeat.html"
                                  title='struct syn::ExprRepeat'>ExprRepeat</a></td>
                           <td class='docblock-short'>
                                <p>An array literal constructed from one repeated element: <code>[0u8; N]</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprReturn.html"
                                  title='struct syn::ExprReturn'>ExprReturn</a></td>
                           <td class='docblock-short'>
                                <p>A <code>return</code>, with an optional value to be returned.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprStruct.html"
                                  title='struct syn::ExprStruct'>ExprStruct</a></td>
                           <td class='docblock-short'>
                                <p>A struct literal expression: <code>Point { x: 1, y: 1 }</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprTry.html"
                                  title='struct syn::ExprTry'>ExprTry</a></td>
                           <td class='docblock-short'>
                                <p>A try-expression: <code>expr?</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprTuple.html"
                                  title='struct syn::ExprTuple'>ExprTuple</a></td>
                           <td class='docblock-short'>
                                <p>A tuple expression: <code>(a, b, c, d)</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprType.html"
                                  title='struct syn::ExprType'>ExprType</a></td>
                           <td class='docblock-short'>
                                <p>A type ascription expression: <code>foo: f64</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprUnary.html"
                                  title='struct syn::ExprUnary'>ExprUnary</a></td>
                           <td class='docblock-short'>
                                <p>A unary operation: <code>!x</code>, <code>*x</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprUnsafe.html"
                                  title='struct syn::ExprUnsafe'>ExprUnsafe</a></td>
                           <td class='docblock-short'>
                                <p>An unsafe block: <code>unsafe { ... }</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprVerbatim.html"
                                  title='struct syn::ExprVerbatim'>ExprVerbatim</a></td>
                           <td class='docblock-short'>
                                <p>Tokens in expression position not interpreted by Syn.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprWhile.html"
                                  title='struct syn::ExprWhile'>ExprWhile</a></td>
                           <td class='docblock-short'>
                                <p>A while loop: <code>while expr { ... }</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprWhileLet.html"
                                  title='struct syn::ExprWhileLet'>ExprWhileLet</a></td>
                           <td class='docblock-short'>
                                <p>A while-let loop: <code>while let pat = expr { ... }</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ExprYield.html"
                                  title='struct syn::ExprYield'>ExprYield</a></td>
                           <td class='docblock-short'>
                                <p>A yield expression: <code>yield expr</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Field.html"
                                  title='struct syn::Field'>Field</a></td>
                           <td class='docblock-short'>
                                <p>A field of a struct or enum variant.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.FieldsNamed.html"
                                  title='struct syn::FieldsNamed'>FieldsNamed</a></td>
                           <td class='docblock-short'>
                                <p>Named fields of a struct or struct variant such as <code>Point { x: f64, y: f64 }</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.FieldsUnnamed.html"
                                  title='struct syn::FieldsUnnamed'>FieldsUnnamed</a></td>
                           <td class='docblock-short'>
                                <p>Unnamed fields of a tuple struct or tuple variant such as <code>Some(T)</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Generics.html"
                                  title='struct syn::Generics'>Generics</a></td>
                           <td class='docblock-short'>
                                <p>Lifetimes and type parameters attached to a declaration of a function,
enum, trait, etc.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Ident.html"
                                  title='struct syn::Ident'>Ident</a></td>
                           <td class='docblock-short'>
                                <p>A word of Rust code, which may be a keyword or legal variable name.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ImplGenerics.html"
                                  title='struct syn::ImplGenerics'>ImplGenerics</a></td>
                           <td class='docblock-short'>
                                <p>Returned by <code>Generics::split_for_impl</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Index.html"
                                  title='struct syn::Index'>Index</a></td>
                           <td class='docblock-short'>
                                <p>The index of an unnamed tuple struct field.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Lifetime.html"
                                  title='struct syn::Lifetime'>Lifetime</a></td>
                           <td class='docblock-short'>
                                <p>A Rust lifetime: <code>'a</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.LifetimeDef.html"
                                  title='struct syn::LifetimeDef'>LifetimeDef</a></td>
                           <td class='docblock-short'>
                                <p>A lifetime definition: <code>'a: 'b + 'c + 'd</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.LitBool.html"
                                  title='struct syn::LitBool'>LitBool</a></td>
                           <td class='docblock-short'>
                                <p>A boolean literal: <code>true</code> or <code>false</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.LitByte.html"
                                  title='struct syn::LitByte'>LitByte</a></td>
                           <td class='docblock-short'>
                                <p>A byte literal: <code>b'f'</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.LitByteStr.html"
                                  title='struct syn::LitByteStr'>LitByteStr</a></td>
                           <td class='docblock-short'>
                                <p>A byte string literal: <code>b&quot;foo&quot;</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.LitChar.html"
                                  title='struct syn::LitChar'>LitChar</a></td>
                           <td class='docblock-short'>
                                <p>A character literal: <code>'a'</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.LitFloat.html"
                                  title='struct syn::LitFloat'>LitFloat</a></td>
                           <td class='docblock-short'>
                                <p>A floating point literal: <code>1f64</code> or <code>1.0e10f64</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.LitInt.html"
                                  title='struct syn::LitInt'>LitInt</a></td>
                           <td class='docblock-short'>
                                <p>An integer literal: <code>1</code> or <code>1u16</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.LitStr.html"
                                  title='struct syn::LitStr'>LitStr</a></td>
                           <td class='docblock-short'>
                                <p>A UTF-8 string literal: <code>&quot;foo&quot;</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.LitVerbatim.html"
                                  title='struct syn::LitVerbatim'>LitVerbatim</a></td>
                           <td class='docblock-short'>
                                <p>A raw token literal not interpreted by Syn, possibly because it
represents an integer larger than 64 bits.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Macro.html"
                                  title='struct syn::Macro'>Macro</a></td>
                           <td class='docblock-short'>
                                <p>A macro invocation: <code>println!(&quot;{}&quot;, mac)</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.MetaList.html"
                                  title='struct syn::MetaList'>MetaList</a></td>
                           <td class='docblock-short'>
                                <p>A structured list within an attribute, like <code>derive(Copy, Clone)</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.MetaNameValue.html"
                                  title='struct syn::MetaNameValue'>MetaNameValue</a></td>
                           <td class='docblock-short'>
                                <p>A name-value pair within an attribute, like <code>feature = &quot;nightly&quot;</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ParenthesizedGenericArguments.html"
                                  title='struct syn::ParenthesizedGenericArguments'>ParenthesizedGenericArguments</a></td>
                           <td class='docblock-short'>
                                <p>Arguments of a function path segment: the <code>(A, B) -&gt; C</code> in <code>Fn(A,B) -&gt; C</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Path.html"
                                  title='struct syn::Path'>Path</a></td>
                           <td class='docblock-short'>
                                <p>A path at which a named item is exported: <code>std::collections::HashMap</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.PathSegment.html"
                                  title='struct syn::PathSegment'>PathSegment</a></td>
                           <td class='docblock-short'>
                                <p>A segment of a path together with any path arguments on that segment.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.PathTokens.html"
                                  title='struct syn::PathTokens'>PathTokens</a></td>
                           <td class='docblock-short'>
                                <p>A helper for printing a self-type qualified path as tokens.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.PredicateEq.html"
                                  title='struct syn::PredicateEq'>PredicateEq</a></td>
                           <td class='docblock-short'>
                                <p>An equality predicate in a <code>where</code> clause (unsupported).</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.PredicateLifetime.html"
                                  title='struct syn::PredicateLifetime'>PredicateLifetime</a></td>
                           <td class='docblock-short'>
                                <p>A lifetime predicate in a <code>where</code> clause: <code>'a: 'b + 'c</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.PredicateType.html"
                                  title='struct syn::PredicateType'>PredicateType</a></td>
                           <td class='docblock-short'>
                                <p>A type predicate in a <code>where</code> clause: <code>for&lt;'c&gt; Foo&lt;'c&gt;: Trait&lt;'c&gt;</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.QSelf.html"
                                  title='struct syn::QSelf'>QSelf</a></td>
                           <td class='docblock-short'>
                                <p>The explicit Self type in a qualified path: the <code>T</code> in <code>&lt;T as Display&gt;::fmt</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.TraitBound.html"
                                  title='struct syn::TraitBound'>TraitBound</a></td>
                           <td class='docblock-short'>
                                <p>A trait used as a bound on a type parameter.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Turbofish.html"
                                  title='struct syn::Turbofish'>Turbofish</a></td>
                           <td class='docblock-short'>
                                <p>Returned by <code>TypeGenerics::as_turbofish</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.TypeArray.html"
                                  title='struct syn::TypeArray'>TypeArray</a></td>
                           <td class='docblock-short'>
                                <p>A fixed size array type: <code>[T; n]</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.TypeBareFn.html"
                                  title='struct syn::TypeBareFn'>TypeBareFn</a></td>
                           <td class='docblock-short'>
                                <p>A bare function type: <code>fn(usize) -&gt; bool</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.TypeGenerics.html"
                                  title='struct syn::TypeGenerics'>TypeGenerics</a></td>
                           <td class='docblock-short'>
                                <p>Returned by <code>Generics::split_for_impl</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.TypeGroup.html"
                                  title='struct syn::TypeGroup'>TypeGroup</a></td>
                           <td class='docblock-short'>
                                <p>A type contained within invisible delimiters.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.TypeImplTrait.html"
                                  title='struct syn::TypeImplTrait'>TypeImplTrait</a></td>
                           <td class='docblock-short'>
                                <p>An <code>impl Bound1 + Bound2 + Bound3</code> type where <code>Bound</code> is a trait or
a lifetime.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.TypeInfer.html"
                                  title='struct syn::TypeInfer'>TypeInfer</a></td>
                           <td class='docblock-short'>
                                <p>Indication that a type should be inferred by the compiler: <code>_</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.TypeMacro.html"
                                  title='struct syn::TypeMacro'>TypeMacro</a></td>
                           <td class='docblock-short'>
                                <p>A macro in the type position.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.TypeNever.html"
                                  title='struct syn::TypeNever'>TypeNever</a></td>
                           <td class='docblock-short'>
                                <p>The never type: <code>!</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.TypeParam.html"
                                  title='struct syn::TypeParam'>TypeParam</a></td>
                           <td class='docblock-short'>
                                <p>A generic type parameter: <code>T: Into&lt;String&gt;</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.TypeParen.html"
                                  title='struct syn::TypeParen'>TypeParen</a></td>
                           <td class='docblock-short'>
                                <p>A parenthesized type equivalent to the inner type.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.TypePath.html"
                                  title='struct syn::TypePath'>TypePath</a></td>
                           <td class='docblock-short'>
                                <p>A path like <code>std::slice::Iter</code>, optionally qualified with a
self-type as in <code>&lt;Vec&lt;T&gt; as SomeTrait&gt;::Associated</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.TypePtr.html"
                                  title='struct syn::TypePtr'>TypePtr</a></td>
                           <td class='docblock-short'>
                                <p>A raw pointer type: <code>*const T</code> or <code>*mut T</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.TypeReference.html"
                                  title='struct syn::TypeReference'>TypeReference</a></td>
                           <td class='docblock-short'>
                                <p>A reference type: <code>&amp;'a T</code> or <code>&amp;'a mut T</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.TypeSlice.html"
                                  title='struct syn::TypeSlice'>TypeSlice</a></td>
                           <td class='docblock-short'>
                                <p>A dynamically sized slice type: <code>[T]</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.TypeTraitObject.html"
                                  title='struct syn::TypeTraitObject'>TypeTraitObject</a></td>
                           <td class='docblock-short'>
                                <p>A trait object type <code>Bound1 + Bound2 + Bound3</code> where <code>Bound</code> is a
trait or a lifetime.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.TypeTuple.html"
                                  title='struct syn::TypeTuple'>TypeTuple</a></td>
                           <td class='docblock-short'>
                                <p>A tuple type: <code>(A, B, C, String)</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.TypeVerbatim.html"
                                  title='struct syn::TypeVerbatim'>TypeVerbatim</a></td>
                           <td class='docblock-short'>
                                <p>Tokens in type position not interpreted by Syn.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Variant.html"
                                  title='struct syn::Variant'>Variant</a></td>
                           <td class='docblock-short'>
                                <p>An enum variant.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.VisCrate.html"
                                  title='struct syn::VisCrate'>VisCrate</a></td>
                           <td class='docblock-short'>
                                <p>A crate-level visibility: <code>crate</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.VisPublic.html"
                                  title='struct syn::VisPublic'>VisPublic</a></td>
                           <td class='docblock-short'>
                                <p>A public visibility level: <code>pub</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.VisRestricted.html"
                                  title='struct syn::VisRestricted'>VisRestricted</a></td>
                           <td class='docblock-short'>
                                <p>A visibility level restricted to some path: <code>pub(self)</code> or
<code>pub(super)</code> or <code>pub(crate)</code> or <code>pub(in some::module)</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.WhereClause.html"
                                  title='struct syn::WhereClause'>WhereClause</a></td>
                           <td class='docblock-short'>
                                <p>A <code>where</code> clause in a definition: <code>where T: Deserialize&lt;'de&gt;, D: 'static</code>.</p>

                           </td>
                       </tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.AttrStyle.html"
                                  title='enum syn::AttrStyle'>AttrStyle</a></td>
                           <td class='docblock-short'>
                                <p>Distinguishes between attributes that decorate an item and attributes
that are contained within an item.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.BareFnArgName.html"
                                  title='enum syn::BareFnArgName'>BareFnArgName</a></td>
                           <td class='docblock-short'>
                                <p>Name of an argument in a function type: the <code>n</code> in <code>fn(n: usize)</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.BinOp.html"
                                  title='enum syn::BinOp'>BinOp</a></td>
                           <td class='docblock-short'>
                                <p>A binary operator: <code>+</code>, <code>+=</code>, <code>&amp;</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.Data.html"
                                  title='enum syn::Data'>Data</a></td>
                           <td class='docblock-short'>
                                <p>The storage of a struct, enum or union data structure.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.Expr.html"
                                  title='enum syn::Expr'>Expr</a></td>
                           <td class='docblock-short'>
                                <p>A Rust expression.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.Fields.html"
                                  title='enum syn::Fields'>Fields</a></td>
                           <td class='docblock-short'>
                                <p>Data stored within an enum variant or struct.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.FloatSuffix.html"
                                  title='enum syn::FloatSuffix'>FloatSuffix</a></td>
                           <td class='docblock-short'>
                                <p>The suffix on a floating point literal if any, like the <code>f32</code> in
<code>1.0f32</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.GenericArgument.html"
                                  title='enum syn::GenericArgument'>GenericArgument</a></td>
                           <td class='docblock-short'>
                                <p>An individual generic argument, like <code>'a</code>, <code>T</code>, or <code>Item = T</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.GenericParam.html"
                                  title='enum syn::GenericParam'>GenericParam</a></td>
                           <td class='docblock-short'>
                                <p>A generic type parameter, lifetime, or const generic: <code>T: Into&lt;String&gt;</code>,
<code>'a: 'b</code>, <code>const LEN: usize</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.IntSuffix.html"
                                  title='enum syn::IntSuffix'>IntSuffix</a></td>
                           <td class='docblock-short'>
                                <p>The suffix on an integer literal if any, like the <code>u8</code> in <code>127u8</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.Lit.html"
                                  title='enum syn::Lit'>Lit</a></td>
                           <td class='docblock-short'>
                                <p>A Rust literal such as a string or integer or boolean.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.MacroDelimiter.html"
                                  title='enum syn::MacroDelimiter'>MacroDelimiter</a></td>
                           <td class='docblock-short'>
                                <p>A grouping token that surrounds a macro body: <code>m!(...)</code> or <code>m!{...}</code> or <code>m![...]</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.Member.html"
                                  title='enum syn::Member'>Member</a></td>
                           <td class='docblock-short'>
                                <p>A struct or tuple struct field accessed in a struct literal or field
expression.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.Meta.html"
                                  title='enum syn::Meta'>Meta</a></td>
                           <td class='docblock-short'>
                                <p>Content of a compile-time structured attribute.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.NestedMeta.html"
                                  title='enum syn::NestedMeta'>NestedMeta</a></td>
                           <td class='docblock-short'>
                                <p>Element of a compile-time attribute list.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.PathArguments.html"
                                  title='enum syn::PathArguments'>PathArguments</a></td>
                           <td class='docblock-short'>
                                <p>Angle bracketed or parenthesized arguments of a path segment.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.ReturnType.html"
                                  title='enum syn::ReturnType'>ReturnType</a></td>
                           <td class='docblock-short'>
                                <p>Return type of a function signature.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.StrStyle.html"
                                  title='enum syn::StrStyle'>StrStyle</a></td>
                           <td class='docblock-short'>
                                <p>The style of a string literal, either plain quoted or a raw string like
<code>r##&quot;data&quot;##</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.TraitBoundModifier.html"
                                  title='enum syn::TraitBoundModifier'>TraitBoundModifier</a></td>
                           <td class='docblock-short'>
                                <p>A modifier on a trait bound, currently only used for the <code>?</code> in
<code>?Sized</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.Type.html"
                                  title='enum syn::Type'>Type</a></td>
                           <td class='docblock-short'>
                                <p>The possible types that a Rust value could have.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.TypeParamBound.html"
                                  title='enum syn::TypeParamBound'>TypeParamBound</a></td>
                           <td class='docblock-short'>
                                <p>A trait or lifetime used as a bound on a type parameter.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.UnOp.html"
                                  title='enum syn::UnOp'>UnOp</a></td>
                           <td class='docblock-short'>
                                <p>A unary operator: <code>*</code>, <code>!</code>, <code>-</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.Visibility.html"
                                  title='enum syn::Visibility'>Visibility</a></td>
                           <td class='docblock-short'>
                                <p>The visibility level of an item: inherited or <code>pub</code> or
<code>pub(restricted)</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.WherePredicate.html"
                                  title='enum syn::WherePredicate'>WherePredicate</a></td>
                           <td class='docblock-short'>
                                <p>A single predicate in a <code>where</code> clause: <code>T: Deserialize&lt;'de&gt;</code>.</p>

                           </td>
                       </tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.parse.html"
                                  title='fn syn::parse'>parse</a></td>
                           <td class='docblock-short'>
                                <p>Parse tokens of source code into the chosen syntax tree node.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.parse2.html"
                                  title='fn syn::parse2'>parse2</a></td>
                           <td class='docblock-short'>
                                <p>Parse a proc-macro2 token stream into the chosen syntax tree node.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.parse_str.html"
                                  title='fn syn::parse_str'>parse_str</a></td>
                           <td class='docblock-short'>
                                <p>Parse a string of Rust code into the chosen syntax tree node.</p>

                           </td>
                       </tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g. <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g. <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g. <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "syn";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>